# Chapter 2: File input/output

Okay, so Chapter 1 was the whole enchilada...

... *d-mnit, now I'm HANGRY!*

... everything else is just details.

So: details.

## Lines

We want to read a CSV (comma separated values) file and count the number of
lines in the file. Because who doesn't want to do that? That is: process a
file, line-by-line.

We doesn't not want to do that, that's who! SO THERE!

The CSV file is [here](/src/book/book1/cmc-coins.csv)

This program reads the file name from the command line (as opposed to reading
from standard input), then 'parses' the file by breaking it up by lines and
counting the lines, returning that as the result.

So. What do I call this thing? That's always the hardest thing for me: names,
naming characters in my stories, naming programs, naming functions.

Names.

I'll name this program `wc`.

```Haskell
import System.Environment (getArgs)

main :: IO ()
main = getArgs >>=  mapM_ wc

wc :: FilePath -> IO ()
wc f = readFile f >>= 
       putStrLn 
              . ((f ++ " has ") ++) . (++ " lines.")
              . show . length . lines
```

[src](/src/book/book1/ex2a-line-count.hs)

### Unus

```bash
$ cd src/book/book1
$ ghc ex2a-line-count.hs -o wc
```

... *program compiles, like, instantaneously*

```bash
$ ./wc cmc-coins.csv
cmc-coins.csv has 33 lines.
```

### Explanation

Is there a lot to unpack here? Not really.

1. We import `getArgs` to get all the files to process
2. We then loop through each file, mapping the file name to a process, `wc`.

In `wc`, we:

3. read the file, obvie.
4. Then, going backwards from here *(because `(.)` pipes the flow of data 
from right to left)*

<blockquote>
<ol type='a'>
   <li><code>lines</code> breaks the file into an array of lines</li>
   <li><code>length</code> converts a list into its length (or: *folds* the list into the 
count)</li>
   <li><code>show</code> converts any (showable) value to its string representation</li>
   <li>which then feeds that result (the line-count) to the output string.</li>
</ol>
</blockquote>

### Duus

Okay, that was one file, can we do more than one file? Let's try.

```bash
./wc cmc-coins.csv ex2-wc.hs
cmc-coins.csv has 33 lines.
ex2a-line-count.hs has 13 lines.
```

That was easy!

Note something interesting here: the program `ex2a-line-count.hs` counts the
lines of files (data), but it, itself, is data for the program.

The program is data!

Computer scientists get all excited about stuff like this.

## Words

Okay, we've counted the lines of files, but let's look, in particular, at 
the CSV file. The first few lines look like this:

```CSV
Coin Prices,,,,
,,,,
for_date,cmc_id,coin,price (USD),id
2022-07-09,7278,AAVE,$74.50,
2022-07-09,4030,ALGO,$0.32,
```

Here we see the first three lines are meta-data.

You know what meta-data is?

Useless to us in this exercise.*

*translation "this exercise": always.

So, we want to drop the first three lines.

Now, the other lines, we want to get the token name (coin) and the cmc_id, so
we can, eventually, print it out, but let's store it in a structure as we read
the file:

```Haskell
data Coin = Coin { cmc_id :: Integer, name :: String }
   deriving (Eq, Ord, Show)
```

A data-structure is all well and good, but we need to scan each line and extract
the associated values. And how do we do that? We [split](https://stackoverflow.com/questions/4978578/how-to-split-a-string-in-haskell) the line into its
distinct elements, then populate the Coin data type with the relevant values.

Our new program looks like this:

```Haskell
import System.Environment (getArgs)

data Coin = Coin { cmc_id :: Integer, name :: String }
   deriving (Eq, Ord, Show)

main :: IO ()
main = getArgs >>= mapM_ coinM

coinM :: FilePath -> IO ()
coinM f = putStrLn ("Coins in " ++ f ++ ":\n") >>
          readFile f >>=
          mapM_ print . map (encoin . csv) . drop 3 . lines

csv :: String -> [String]
csv = split ','

-- https://stackoverflow.com/questions/4978578/how-to-split-a-string-in-haskell
-- Frank Meisschaert answer

split :: Char -> String -> [String]
split d [] = []
split d s = x : split d (drop 1 y) where (x,y) = span (/= d) s

encoin :: [String] -> Coin
encoin (_:cmc_id:name:_) = Coin (read cmc_id) name
```

[src](/src/book/book1/ex2b-csv-parser.hs)

And we run this puppy thusly:

```bash
$ cd src/book/book1/
$ ghc ex2b-csv-parser.hs -o cs
```

... `cs` *for 'coin scanner.'*

```bash
$ ./cs cmc-coins.csv 
Coins in cmc-coins.csv:

Coin {cmc_id = 7278, name = "AAVE"}
Coin {cmc_id = 4030, name = "ALGO"}
Coin {cmc_id = 8857, name = "ANC"}
Coin {cmc_id = 3794, name = "ATOM"}
... etc
```
